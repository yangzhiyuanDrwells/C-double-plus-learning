lambda 表达式是 C++11 最重要也最常用的一个特性之一，C# 3.5 和 Java 8 中就引入了 lambda 表达式。

lambda 来源于函数式编程的概念，也是现代编程语言的一个特点。C++11 这次终于把 lambda 加进来了。

lambda表达式有如下优点：
- 声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。
- 简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。
- 在需要的时间和地点实现功能闭包，使程序更灵活。


## lambda 表达式的概念和基本用法

lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：

    [ capture ] ( params ) opt -> ret { body; };

其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。

因此，一个完整的 lambda 表达式看起来像这样：

    auto f = [](int a) -> int { return a + 1; };
    std::cout << f(1) << std::endl;  // 输出: 2

可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。

在 C++11 中，lambda 表达式的返回值是通过前面介绍的《C++返回值类型后置》语法来定义的。其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：

    auto f = [](int a){ return a + 1; };

这样编译器就会根据 return 语句自动推导出返回值类型。

需要注意的是，初始化列表不能用于返回值的自动推导：

    auto x1 = [](int i){ return i; };  // OK: return type is int
    auto x2 = [](){ return { 1, 2 }; };  // error: 无法推导出返回值类型

这时我们需要显式给出具体的返回值类型。

另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：

    auto f1 = [](){ return 1; };
    auto f2 = []{ return 1; };  // 省略空参数表

使用 lambda 表达式捕获列表
lambda 表达式还可以通过捕获列表捕获一定范围内的变量：
- [] 不捕获任何变量。
- [&] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
- [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。
- [=，&foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
- [bar] 按值捕获 bar 变量，同时不捕获其他变量。
- [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。

下面看一下它的具体用法，如下所示。

##### 【实例】lambda 表达式的基本用法。<a href="">lam1.cpp</a>

从上例中可以看到，lambda 表达式的捕获列表精细地控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。

需要注意的是，默认状态下 lambda 表达式无法修改通过复制方式捕获的外部变量。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。

一个容易出错的细节是关于 lambda 表达式的延迟调用的：

    int a = 0;
    auto f = [=]{ return a; };      // 按值捕获外部变量
    a += 1;                         // a被修改了
    std::cout << f() << std::endl;  // 输出？

在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。

如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。

从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被复制了一份存储在 lambda 表达式变量中。此时虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却仍然无法修改它们。

那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：

    int a = 0;
    auto f1 = [=]{ return a++; };             // error，修改按值捕获的外部变量
    auto f2 = [=]() mutable { return a++; };  // OK，mutable

需要注意的一点是，被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。

## lambda 表达式的类型


lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。

因此，我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：

    std::function<int(int)>  f1 = [](int a){ return a; };
    std::function<int(void)> f2 = std::bind([](int a){ return a; }, 123);

另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：

    using func_t = int(*)(int);
    func_t f = [](int a){ return a; };
    f(123);

lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。

这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() 默认是 const 的。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。

需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：

    typedef void(*Ptr)(int*);
    Ptr p = [](int* p){delete p;};  // 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针
    Ptr p1 = [&](int* p){delete p;};  // 错误，有状态的lambda
    不能直接转换为函数指针

上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。
声明式的编程风格，简洁的代码
就地定义匿名函数，不再需要定义函数对象，大大简化了标准库算法的调用。比如，在 C++11 之前，我们要调用 for_each 函数将 vector 中的偶数打印出来，如下所示。

##### 【实例】lambda 表达式代替函数对象的示例<a href="">lam2.cpp</a>

这样写既烦琐又容易出错。有了 lambda 表达式以后，我们可以使用真正的闭包概念来替换掉这里的仿函数，代码如下：

    std::vector<int> v = { 1, 2, 3, 4, 5, 6 };
    int even_count = 0;
    for_each( v.begin(), v.end(), [&even_count](int val)
            {
                if (!(val & 1))  // val % 2 == 0
                {
                    ++ even_count;
                }
            });
    std::cout << "The number of even is " << even_count << std::endl;

lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。